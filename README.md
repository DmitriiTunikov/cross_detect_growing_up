#Установка#
you need to install opencv library for correct compilation  
look at opencv install tutorial for visual studio https://www.deciphertechnic.com/install-opencv-with-visual-studio/  
#Program input: path_to_image  
#Program output:  
image with intersection points and image with detected rails  
#Dataset:  
Images on which you can test my program stores in foldet: data/  

#Алгоритм  
* Преобразуем изображение с черно-белые тона  
* С помощью оператора Собеля находим карту градиентов изображения - величина и направление градиента в каждой точке.  
* Составляем 8 интегральных изображений для каждого из направлений градиента - это нужно для быстрого подсчете HOG(гистограммы ориентированных градиентов) в любом прямоугольнике изображения  
* Строим сетку на изображении. Цель построения сетки - на каждом из уровней высоты разбить исходное изображение на квадратики размером, соизмеримым с размером кусочка рельса на данной высоте. То есть в нижней строчке изображения (ближе к камере) разбиение будет крупным, и будет уменьшаться по мере приближения к верхней точке изображения:  
![Разбиение изображения на сетку](/data/grid.jpg).  
* Поиск рельсов на полученной сетке. Для поиска рельсов используется алгоритм growing_up:  
1. Для каждой клетки из нижней строки сетки, пытаемся пойти вверх в центрального, правого или левого соседа. Сосед считается рельсом, если хи-квадрат оценка для гистограммы HOG соседа и гистограммы HOG текущей точки < treashhold = 1.5(подобран экспериментально). Также с помощью HOG соседа проверяется, есть ли вертикальные ребра у этого соседа, если их нет - игнорируем данную клетку. Также если наоброт, есть горизонтальные ребра - игнорируем данную клетку.
2. Таким образом, рекурсивно для каждого вновь появившегося соседа ищутся его соседи, в которых может находиться рельс.  
3. В итоге на выходе из алгоритма имеется набор возрастающих по 'y' наборов клеток, которые и являются рельсами.  
* Поиск пересечений рельсов  
Начиная с первой строки сетки считаем количество рельсов, находящихся в данном строке. Так как иногда один рельс может отражаться двумя и более горизонтальными клетками в строке - такие подряд идущие клетки заменяются одной средней из них.  
Далее, по такой же схеме считаем количество рельсов в следующей строке. И если количество рельсов в текущей и предыдщей строках различное - значит в текущей строке есть пересечение. Это может быть как переход от большего к меньшему количеству рельсов в строке - два пары рельсов сходятся. Так и переход от меньшего к большему количеству рельсов в строке - отделение пути от текущего пути.  
#Проблемы алгоритма  
